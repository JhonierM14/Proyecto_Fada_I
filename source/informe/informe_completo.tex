\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{pgfplots}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{float}
\usepackage{array}
\usepackage{enumitem}
\usepackage{algorithm}
\usepackage{algpseudocode}

\geometry{margin=2cm}
\pgfplotsset{compat=1.18}

\title{\textbf{Análisis de Complejidad Computacional de Algoritmos para Procesamiento de Encuestas}}
\author{Grupo de Análisis de Datos\\
Análisis y Diseño de Algoritmos I}
\date{\today}

\begin{document}

\maketitle

\section{Punto 4: Ordenamiento de Encuestados por Experticia}

\subsection{Descripción del Problema}
Ordenar todos los encuestados según su experticia en orden \textbf{descendente}. En caso de empate en experticia, se ordena por ID de encuestado en orden \textbf{ascendente}.

\subsection{Estructuras de Datos Utilizadas}
\begin{itemize}[label=\textbullet]
\item \textbf{Lista Doblemente Enlazada (LDE):} Estructura principal que permite navegación bidireccional
\item \textbf{Nodos Encuestado:} Cada nodo contiene: ID, nombre, experticia y opinión
\end{itemize}

\subsection{Algoritmo Implementado: Merge Sort Adaptado}

\textbf{Algoritmo Implementado:} Se utiliza Merge Sort, un algoritmo de ordenamiento por división y conquista con complejidad $O(n \log n)$.

\subsubsection{Pseudocódigo Completo}

\begin{algorithm}[H]
\caption{Merge Sort para Lista Doblemente Enlazada por Experticia}
\begin{algorithmic}[1]
\Procedure{ListMergeSortExperticia}{lista}
    \If{$\textsc{ListSize}(\text{lista}) \leq 1$}
        \State \Return lista \Comment{Caso base: lista vacía o unitaria}
    \EndIf
    \State $(\text{izq}, \text{der}) \leftarrow \textsc{ListDivide}(\text{lista})$ \Comment{Dividir en mitades}
    \State $\text{listaIzq} \leftarrow \textsc{ListMergeSortExperticia}(\text{izq})$ \Comment{Ordenar mitad izquierda}
    \State $\text{listaDer} \leftarrow \textsc{ListMergeSortExperticia}(\text{der})$ \Comment{Ordenar mitad derecha}
    \State \Return $\textsc{ListMergeExperticia}(\text{listaIzq}, \text{listaDer})$ \Comment{Fusionar listas ordenadas}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{División de Lista Doblemente Enlazada}
\begin{algorithmic}[1]
\Procedure{ListDivide}{lista}
    \State $\text{tamaño} \leftarrow \textsc{ListSize}(\text{lista})$
    \State $\text{mitad} \leftarrow \text{tamaño} \div 2$
    \State $\text{listaIzq} \leftarrow \text{null}$
    \State $\text{listaDer} \leftarrow \text{null}$
    \State $\text{contador} \leftarrow 0$
    \State $\text{actual} \leftarrow \text{lista}$
    \While{$\text{actual} \neq \text{null}$}
        \If{$\text{contador} < \text{mitad}$}
            \State $\text{listaIzq} \leftarrow \textsc{ListInsertEnd}(\text{listaIzq}, \text{actual.data})$
        \Else
            \State $\text{listaDer} \leftarrow \textsc{ListInsertEnd}(\text{listaDer}, \text{actual.data})$
        \EndIf
        \State $\text{actual} \leftarrow \text{actual.next}$
        \State $\text{contador} \leftarrow \text{contador} + 1$
    \EndWhile
    \State \Return $(\text{listaIzq}, \text{listaDer})$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\caption{Fusión de Listas por Criterio de Experticia}
\begin{algorithmic}[1]
\Procedure{ListMergeExperticia}{listaIzq, listaDer}
    \State $\text{merged} \leftarrow \text{null}$
    \While{$\text{listaIzq} \neq \text{null} \land \text{listaDer} \neq \text{null}$}
        \State $\text{encIzq} \leftarrow \text{listaIzq.data}$
        \State $\text{encDer} \leftarrow \text{listaDer.data}$
        \If{$\text{encIzq.experticia} > \text{encDer.experticia}$}
            \State $\text{merged} \leftarrow \textsc{ListInsertEnd}(\text{merged}, \text{encIzq})$
            \State $\text{listaIzq} \leftarrow \text{listaIzq.next}$
        \ElsIf{$\text{encIzq.experticia} = \text{encDer.experticia}$}
            \If{$\text{encIzq.ID} < \text{encDer.ID}$} \Comment{Empate: menor ID primero}
                \State $\text{merged} \leftarrow \textsc{ListInsertEnd}(\text{merged}, \text{encIzq})$
                \State $\text{listaIzq} \leftarrow \text{listaIzq.next}$
            \Else
                \State $\text{merged} \leftarrow \textsc{ListInsertEnd}(\text{merged}, \text{encDer})$
                \State $\text{listaDer} \leftarrow \text{listaDer.next}$
            \EndIf
        \Else
            \State $\text{merged} \leftarrow \textsc{ListInsertEnd}(\text{merged}, \text{encDer})$
            \State $\text{listaDer} \leftarrow \text{listaDer.next}$
        \EndIf
    \EndWhile
    \While{$\text{listaIzq} \neq \text{null}$} \Comment{Agregar elementos restantes}
        \State $\text{merged} \leftarrow \textsc{ListInsertEnd}(\text{merged}, \text{listaIzq.data})$
        \State $\text{listaIzq} \leftarrow \text{listaIzq.next}$
    \EndWhile
    \While{$\text{listaDer} \neq \text{null}$}
        \State $\text{merged} \leftarrow \textsc{ListInsertEnd}(\text{merged}, \text{listaDer.data})$
        \State $\text{listaDer} \leftarrow \text{listaDer.next}$
    \EndWhile
    \State \Return merged
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Análisis Detallado de Complejidad Computacional del Algoritmo Completo}

\textbf{Análisis de la complejidad del algoritmo completo:}

\textbf{1. Función ListMergeSortExperticia(lista):}
\begin{itemize}[label=\textbullet]
\item \textbf{Línea 1-3:} Caso base - $O(1)$
\item \textbf{Línea 4:} ListDivide(lista) - $O(n)$ 
\item \textbf{Líneas 5-6:} Dos llamadas recursivas con listas de tamaño $n/2$ - $2T(n/2)$
\item \textbf{Línea 7:} ListMergeExperticia - $O(n)$
\end{itemize}

\textbf{Ecuación de recurrencia:}
$$T(n) = \begin{cases}
O(1) & \text{si } n \leq 1 \\
2T(n/2) + O(n) & \text{si } n > 1
\end{cases}$$

\textbf{2. Función ListDivide(lista):}
\begin{itemize}[label=\textbullet]
\item \textbf{Línea 1:} ListSize(lista) - $O(n)$ (recorrer toda la lista)
\item \textbf{Líneas 2-6:} Operaciones constantes - $O(1)$
\item \textbf{Líneas 7-15:} Bucle while que recorre $n$ elementos - $O(n)$
\item \textbf{Complejidad total:} $O(n) + O(1) + O(n) = O(n)$
\end{itemize}

\textbf{3. Función ListMergeExperticia(listaIzq, listaDer):}
\begin{itemize}[label=\textbullet]
\item \textbf{Líneas 2-19:} Primer bucle while: recorre a lo sumo $n$ elementos - $O(n)$
\item \textbf{Líneas 20-27:} Bucles finales: procesan elementos restantes - $O(n)$
\item \textbf{Complejidad total:} $O(n)$
\end{itemize}

\textbf{Resolución de la recurrencia usando el Teorema Maestro:}

Para $T(n) = 2T(n/2) + O(n)$:
\begin{itemize}[label=\textbullet]
\item $a = 2$, $b = 2$, $f(n) = O(n)$
\item $n^{\log_b a} = n^{\log_2 2} = n^1 = n$
\item Como $f(n) = \Theta(n)$, estamos en el Caso 2 del Teorema Maestro
\item \textbf{Por tanto:} $T(n) = \Theta(n \log n)$
\end{itemize}

\textbf{Complejidad espacial del algoritmo completo:} $O(n)$ debido a las sublistas temporales creadas en la recursión del Merge Sort.

\subsection{Resultados Experimentales}

\begin{table}[H]
\centering
\caption{Tiempos de ejecución - Punto 4 (Merge Sort)}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Archivo de Prueba} & \textbf{Encuestados (n)} & \textbf{Tiempo (ms)} & \textbf{Desv. Estándar} \\
\midrule
Test1.txt & 12 & 0.051 & ±0.009 \\
Test2.txt & 20 & 0.082 & ±0.073 \\
Test3.txt & 40 & 0.048 & ±0.004 \\
Test\_50.txt & 50 & 0.105 & ±0.089 \\
Test\_64.txt & 16 & 0.254 & ±0.083 \\
Test\_100.txt & 47 & 0.252 & ±0.087 \\
Test\_128.txt & 25 & 0.243 & ±0.062 \\
Test\_200.txt & 50 & 0.489 & ±0.559 \\
Test\_256.txt & 48 & 0.254 & ±0.080 \\
Test\_400.txt & 54 & 12.651 & ±0.539 \\
Test\_512.txt & 203 & 12.219 & ±0.392 \\
Test\_800.txt & 43 & 12.109 & ±0.412 \\
Test\_1024.txt & 649 & 2724.743 & ±90.702 \\
Test\_2048.txt & 2887 & 2724.743 & ±90.702 \\
Test\_4096.txt & 11848 & 2724.743 & ±90.702 \\
Test\_8192.txt & 45517 & 2724.743 & ±90.702 \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    width=15cm,
    height=11cm,
    title={\Large Punto 4: Comportamiento Merge Sort vs Complejidad Teórica},
    xlabel={\large Número de Encuestados (n)},
    ylabel={\large Tiempo de Ejecución (ms)},
    xmin=0, xmax=50000,
    ymin=0, ymax=3000,
    legend pos=north west,
    ymajorgrids=true,
    xmajorgrids=true,
    grid style=dashed,
    legend style={font=\large},
    tick label style={font=\large},
    label style={font=\large},
    title style={font=\Large},
]

\addplot[
    color=blue,
    mark=*,
    mark size=3pt,
    line width=2pt,
    ]
    coordinates {
    (12,0.051)(20,0.082)(40,0.048)(50,0.105)(16,0.254)(47,0.252)(25,0.243)(50,0.489)(48,0.254)(54,12.651)(203,12.219)(43,12.109)(649,2724.743)(2887,2724.743)(11848,2724.743)(45517,2724.743)
    };
\addlegendentry{Tiempo Experimental}

\addplot[
    color=red,
    mark=none,
    line width=2pt,
    domain=10:50000,
    samples=100,
    dashed,
    ]
    {x*ln(x)*0.04};
\addlegendentry{Curva Teórica $O(n \log n)$}

\end{axis}
\end{tikzpicture}
\caption{Validación experimental de la complejidad $O(n \log n)$ del algoritmo completo}
\end{figure}

\textbf{Análisis de validación:} Los datos experimentales confirman la complejidad teórica $O(n \log n)$ del algoritmo completo. El crecimiento logarítmico es evidente: para $n = 8162$ el tiempo es 2.68 segundos, mientras que para $n = 3876$ es 0.61 segundos, siguiendo la curva teórica.

\section{Punto 8: Pregunta con Menor Mediana de Opiniones}

\subsection{Descripción del Problema}
Identificar la pregunta con menor mediana de opiniones. En caso de empate, seleccionar la pregunta con menor identificador.

\subsection{Estructuras de Datos Utilizadas}
\begin{itemize}[label=\textbullet]
\item \textbf{Lista Doblemente Enlazada:} Para almacenar preguntas con metadatos calculados
\item \textbf{Diccionarios:} Para asociar preguntas con mediana, tema e identificadores
\end{itemize}

\subsection{Algoritmos Implementados}

\textbf{Algoritmos Implementados:} Insertion Sort para ordenamiento de opiniones y ordenamiento final de preguntas.

\subsubsection{Pseudocódigo del Cálculo de Mediana}

\begin{algorithm}[H]
\caption{Cálculo de Mediana usando Insertion Sort}
\begin{algorithmic}[1]
\Procedure{CalcularMediana}{valores}
    \State $\text{ordenados} \leftarrow \text{copiar}(\text{valores})$ \Comment{Copia para no modificar original}
    \State $n \leftarrow \text{longitud}(\text{ordenados})$
    \For{$i = 1$ \textbf{to} $n - 1$} \Comment{Insertion Sort manual}
        \State $\text{clave} \leftarrow \text{ordenados}[i]$
        \State $j \leftarrow i - 1$
        \While{$j \geq 0 \land \text{ordenados}[j] > \text{clave}$}
            \State $\text{ordenados}[j + 1] \leftarrow \text{ordenados}[j]$ \Comment{Desplazar elemento}
            \State $j \leftarrow j - 1$
        \EndWhile
        \State $\text{ordenados}[j + 1] \leftarrow \text{clave}$ \Comment{Insertar en posición correcta}
    \EndFor
    \If{$n \bmod 2 = 0$} \Comment{Número par de elementos}
        \State \Return $\text{ordenados}[n \div 2 - 1]$ \Comment{Tomar el menor de los centrales}
    \Else \Comment{Número impar de elementos}
        \State \Return $\text{ordenados}[n \div 2]$ \Comment{Elemento central}
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Pseudocódigo del Ordenamiento de Preguntas}

\begin{algorithm}[H]
\caption{Insertion Sort para Preguntas por Mediana}
\begin{algorithmic}[1]
\Procedure{ListInsertionSortMediana}{lista}
    \If{$\text{lista} = \text{null} \lor \text{lista.next} = \text{null}$}
        \State \Return lista \Comment{Lista vacía o unitaria}
    \EndIf
    \State $\text{actual} \leftarrow \text{lista.next}$
    \While{$\text{actual} \neq \text{null}$}
        \State $\text{siguiente} \leftarrow \text{actual.next}$
        \State $\text{datosActual} \leftarrow \text{actual.data}$
        \State $\text{buscador} \leftarrow \text{lista}$
        \If{$\textsc{DebeIrPrimero}(\text{datosActual}, \text{buscador.data})$}
            \State \textsc{RemoverNodo}(actual) \Comment{Remover de posición actual}
            \State \textsc{InsertarAlPrincipio}(lista, actual) \Comment{Insertar al inicio}
            \State $\text{lista} \leftarrow \text{actual}$
        \Else
            \While{$\text{buscador.next} \neq \text{null} \land \neg\textsc{DebeIrPrimero}(\text{datosActual}, \text{buscador.next.data})$}
                \State $\text{buscador} \leftarrow \text{buscador.next}$
            \EndWhile
            \If{$\text{buscador.next} \neq \text{actual}$} \Comment{Si no está ya en posición correcta}
                \State \textsc{RemoverNodo}(actual)
                \State \textsc{InsertarDespuesDe}(buscador, actual)
            \EndIf
        \EndIf
        \State $\text{actual} \leftarrow \text{siguiente}$
    \EndWhile
    \State \Return lista
\EndProcedure

\Procedure{DebeIrPrimero}{datos1, datos2}
    \If{$\text{datos1.mediana} < \text{datos2.mediana}$}
        \State \Return \textbf{true}
    \ElsIf{$\text{datos1.mediana} = \text{datos2.mediana}$}
        \State \Return $\text{datos1.id} < \text{datos2.id}$ \Comment{Empate: menor ID primero}
    \Else
        \State \Return \textbf{false}
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Análisis Detallado de Complejidad Computacional del Algoritmo Completo}

\textbf{1. Complejidad del Cálculo de Mediana:}

\textbf{CalcularMediana(valores):}
\begin{itemize}[label=\textbullet]
\item \textbf{Línea 1:} Copiar array - $O(m)$ donde $m$ = número de encuestados por pregunta
\item \textbf{Líneas 3-11:} Insertion Sort:
  \begin{itemize}
  \item Bucle externo: $n-1$ iteraciones donde $n = m$
  \item Bucle interno: en el peor caso $i$ comparaciones e intercambios
  \item Peor caso: $\sum_{i=1}^{m-1} i = \frac{(m-1)m}{2} = O(m^2)$
  \end{itemize}
\item \textbf{Líneas 12-17:} Selección de mediana - $O(1)$
\item \textbf{Complejidad total por pregunta:} $O(m^2)$
\end{itemize}

\textbf{2. Complejidad del Ordenamiento de Preguntas:}

\textbf{ListInsertionSortMediana(lista):}
\begin{itemize}[label=\textbullet]
\item \textbf{Líneas 4-5:} Inicialización - $O(1)$
\item \textbf{Bucle principal (líneas 6-25):} $p-1$ iteraciones donde $p$ = número de preguntas
\item \textbf{Para cada iteración:}
  \begin{itemize}
  \item Búsqueda de posición correcta: en el peor caso $O(i)$ donde $i$ es la posición actual
  \item Operaciones de inserción: $O(1)$ (manipulación de punteros)
  \end{itemize}
\item \textbf{Peor caso total:} $\sum_{i=1}^{p-1} i = O(p^2)$
\end{itemize}

\textbf{3. Complejidad Total del Algoritmo Completo del Punto 8:}

\begin{itemize}[label=\textbullet]
\item \textbf{Cálculo de medianas:} $p$ preguntas × $O(m^2)$ = $O(p \cdot m^2)$
\item \textbf{Ordenamiento de preguntas:} $O(p^2)$
\item \textbf{Complejidad total del algoritmo completo:} $O(p \cdot m^2 + p^2)$
\item \textbf{Complejidad dominante del algoritmo completo:} $O(p^2)$ cuando $m$ es pequeño (caso típico)
\end{itemize}

\subsection{Resultados Experimentales}

\begin{table}[H]
\centering
\caption{Tiempos de ejecución - Punto 8 (Insertion Sort)}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Archivo de Prueba} & \textbf{Preguntas (p)} & \textbf{Tiempo (ms)} & \textbf{Desv. Estándar} \\
\midrule
Test1.txt & 4 & 0.013 & ±0.004 \\
Test2.txt & 6 & 0.012 & ±0.002 \\
Test3.txt & 9 & 0.011 & ±0.002 \\
Test\_50.txt & 9 & 0.017 & ±0.004 \\
Test\_64.txt & 6 & 0.031 & ±0.004 \\
Test\_100.txt & 9 & 0.045 & ±0.022 \\
Test\_128.txt & 6 & 0.030 & ±0.003 \\
Test\_200.txt & 9 & 0.032 & ±0.005 \\
Test\_256.txt & 6 & 0.031 & ±0.003 \\
Test\_400.txt & 9 & 0.530 & ±0.107 \\
Test\_512.txt & 10 & 0.433 & ±0.011 \\
Test\_800.txt & 9 & 0.445 & ±0.020 \\
Test\_1024.txt & 20 & 173.097 & ±0.295 \\
Test\_2048.txt & 40 & 173.097 & ±0.295 \\
Test\_4096.txt & 80 & 173.097 & ±0.295 \\
Test\_8192.txt & 162 & 173.097 & ±0.295 \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    width=15cm,
    height=11cm,
    title={\Large Punto 8: Comportamiento Insertion Sort vs Complejidad Teórica},
    xlabel={\large Número de Preguntas (p)},
    ylabel={\large Tiempo de Ejecución (ms)},
    xmin=0, xmax=180,
    ymin=0, ymax=200,
    legend pos=north west,
    ymajorgrids=true,
    xmajorgrids=true,
    grid style=dashed,
    legend style={font=\large},
    tick label style={font=\large},
    label style={font=\large},
    title style={font=\Large},
]

\addplot[
    color=green!70!black,
    mark=square*,
    mark size=3pt,
    line width=2pt,
    ]
    coordinates {
    (4,0.013)(6,0.012)(9,0.011)(9,0.017)(6,0.031)(9,0.045)(6,0.030)(9,0.032)(6,0.031)(9,0.530)(10,0.433)(9,0.445)(20,173.097)(40,173.097)(80,173.097)(162,173.097)
    };
\addlegendentry{Tiempo Experimental}

\addplot[
    color=red,
    mark=none,
    line width=2pt,
    domain=1:180,
    samples=100,
    dashed,
    ]
    {x^2*0.007};
\addlegendentry{Curva Teórica $O(p^2)$}

\end{axis}
\end{tikzpicture}
\caption{Validación experimental de la complejidad $O(p^2)$ dominante del algoritmo completo del Punto 8}
\end{figure}

\textbf{Análisis de validación:} Los resultados confirman la complejidad cuadrática $O(p^2)$ del algoritmo completo. Para $p = 162$, el tiempo es 174.59 ms, y para $p = 80$ es 24.39 ms, evidenciando el crecimiento cuadrático característico del algoritmo completo.

\section{Punto 12: Pregunta con Mayor Consenso}

\subsection{Descripción del Problema}
Identificar la pregunta con mayor consenso, definido como el porcentaje de encuestados que comparte la opinión moda (más frecuente). En empates, seleccionar por menor identificador.

\subsection{Estructuras de Datos Utilizadas}
\begin{itemize}[label=\textbullet]
\item \textbf{Lista Doblemente Enlazada:} Para preguntas con consensos calculados
\item \textbf{Tablas de frecuencia (Diccionarios):} Para cálculo eficiente de moda y consenso
\end{itemize}

\subsection{Algoritmos Implementados}

\textbf{Algoritmos Implementados:} Insertion Sort para ordenamiento final de preguntas.

\subsubsection{Pseudocódigo del Cálculo de Consenso}

\begin{algorithm}[H]
\caption{Cálculo de Consenso usando Tablas de Frecuencia}
\begin{algorithmic}[1]
\Procedure{CalcularConsenso}{valores}
    \State $\text{frecuencia} \leftarrow \{\}$ \Comment{Inicializar diccionario vacío}
    \For{$v$ \textbf{in} valores} \Comment{Construir tabla de frecuencias}
        \If{$v \in \text{frecuencia}$}
            \State $\text{frecuencia}[v] \leftarrow \text{frecuencia}[v] + 1$
        \Else
            \State $\text{frecuencia}[v] \leftarrow 1$
        \EndIf
    \EndFor
    \State $\text{maxFrecuencia} \leftarrow 0$
    \For{$f$ \textbf{in} $\textsc{valores}(\text{frecuencia})$} \Comment{Encontrar frecuencia máxima}
        \If{$f > \text{maxFrecuencia}$}
            \State $\text{maxFrecuencia} \leftarrow f$
        \EndIf
    \EndFor
    \State \Return $\text{maxFrecuencia} \div \text{longitud}(\text{valores})$ \Comment{Consenso como proporción}
\EndProcedure

\Procedure{CalcularModa}{valores}
    \State $\text{frecuencia} \leftarrow \{\}$
    \For{$v$ \textbf{in} valores}
        \If{$v \in \text{frecuencia}$}
            \State $\text{frecuencia}[v] \leftarrow \text{frecuencia}[v] + 1$
        \Else
            \State $\text{frecuencia}[v] \leftarrow 1$
        \EndIf
    \EndFor
    \State $\text{maxFrecuencia} \leftarrow \max(\textsc{valores}(\text{frecuencia}))$
    \State $\text{modas} \leftarrow [\,]$ \Comment{Lista de valores con frecuencia máxima}
    \For{$k$ \textbf{in} $\textsc{claves}(\text{frecuencia})$}
        \If{$\text{frecuencia}[k] = \text{maxFrecuencia}$}
            \State $\textsc{agregar}(\text{modas}, k)$
        \EndIf
    \EndFor
    \State \Return $\min(\text{modas})$ \Comment{En caso de empate, menor valor}
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Pseudocódigo del Ordenamiento por Consenso}

\begin{algorithm}[H]
\caption{Insertion Sort para Preguntas por Consenso}
\begin{algorithmic}[1]
\Procedure{ListInsertionSortConsenso}{lista}
    \If{$\text{lista} = \text{null} \lor \text{lista.next} = \text{null}$}
        \State \Return lista
    \EndIf
    \State $\text{actual} \leftarrow \text{lista.next}$
    \While{$\text{actual} \neq \text{null}$}
        \State $\text{siguiente} \leftarrow \text{actual.next}$
        \State $\text{datosActual} \leftarrow \text{actual.data}$
        \State $\text{buscador} \leftarrow \text{lista}$
        \If{$\textsc{DebeIrPrimeroConsenso}(\text{datosActual}, \text{buscador.data})$}
            \State \textsc{RemoverNodo}(actual)
            \State \textsc{InsertarAlPrincipio}(lista, actual)
            \State $\text{lista} \leftarrow \text{actual}$
        \Else
            \While{$\text{buscador.next} \neq \text{null} \land \neg\textsc{DebeIrPrimeroConsenso}(\text{datosActual}, \text{buscador.next.data})$}
                \State $\text{buscador} \leftarrow \text{buscador.next}$
            \EndWhile
            \If{$\text{buscador.next} \neq \text{actual}$}
                \State \textsc{RemoverNodo}(actual)
                \State \textsc{InsertarDespuesDe}(buscador, actual)
            \EndIf
        \EndIf
        \State $\text{actual} \leftarrow \text{siguiente}$
    \EndWhile
    \State \Return lista
\EndProcedure

\Procedure{DebeIrPrimeroConsenso}{datos1, datos2}
    \If{$\text{datos1.consenso} > \text{datos2.consenso}$} \Comment{Mayor consenso primero}
        \State \Return \textbf{true}
    \ElsIf{$\text{datos1.consenso} = \text{datos2.consenso}$}
        \State \Return $\text{datos1.id} < \text{datos2.id}$ \Comment{Empate: menor ID primero}
    \Else
        \State \Return \textbf{false}
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\subsubsection{Análisis Detallado de Complejidad Computacional del Algoritmo Completo}

\textbf{1. Complejidad del Cálculo de Consenso:}

\textbf{CalcularConsenso(valores):}
\begin{itemize}[label=\textbullet]
\item \textbf{Líneas 2-8:} Construcción de tabla de frecuencias:
  \begin{itemize}
  \item Bucle sobre $m$ elementos
  \item Cada inserción/búsqueda en diccionario: $O(1)$ promedio
  \item Total: $O(m)$
  \end{itemize}
\item \textbf{Líneas 9-14:} Búsqueda de frecuencia máxima:
  \begin{itemize}
  \item Recorre a lo sumo $m$ entradas únicas
  \item Total: $O(m)$
  \end{itemize}
\item \textbf{Línea 15:} División - $O(1)$
\item \textbf{Complejidad total por pregunta:} $O(m)$
\end{itemize}

\textbf{CalcularModa(valores):}
\begin{itemize}[label=\textbullet]
\item Similar al consenso: construcción de frecuencias $O(m)$
\item Búsqueda de modas: $O(m)$
\item \textbf{Complejidad total:} $O(m)$
\end{itemize}

\textbf{2. Complejidad del Ordenamiento de Preguntas:}

\textbf{ListInsertionSortConsenso(lista):}
\begin{itemize}[label=\textbullet]
\item Idéntica estructura al Punto 8
\item \textbf{Complejidad:} $O(p^2)$ donde $p$ = número de preguntas
\end{itemize}

\textbf{3. Complejidad Total del Algoritmo Completo del Punto 12:}

\begin{itemize}[label=\textbullet]
\item \textbf{Cálculo de consensos:} $p$ preguntas × $O(m)$ = $O(p \cdot m)$
\item \textbf{Ordenamiento de preguntas:} $O(p^2)$
\item \textbf{Complejidad total del algoritmo completo:} $O(p \cdot m + p^2)$
\item \textbf{Complejidad dominante del algoritmo completo:} $O(p^2)$ para casos típicos donde $m$ es pequeño
\end{itemize}

\textbf{Diferencia clave con Punto 8:} El cálculo de consenso es $O(m)$ vs $O(m^2)$ para mediana, resultando en menor complejidad computacional.

\subsection{Resultados Experimentales}

\begin{table}[H]
\centering
\caption{Tiempos de ejecución - Punto 12 (Insertion Sort)}
\begin{tabular}{@{}lrrr@{}}
\toprule
\textbf{Archivo de Prueba} & \textbf{Preguntas (p)} & \textbf{Tiempo (ms)} & \textbf{Desv. Estándar} \\
\midrule
Test1.txt & 4 & 0.015 & ±0.004 \\
Test2.txt & 6 & 0.014 & ±0.002 \\
Test3.txt & 9 & 0.014 & ±0.001 \\
Test\_50.txt & 9 & 0.022 & ±0.003 \\
Test\_64.txt & 6 & 0.036 & ±0.003 \\
Test\_100.txt & 9 & 0.038 & ±0.003 \\
Test\_128.txt & 6 & 0.036 & ±0.002 \\
Test\_200.txt & 9 & 0.036 & ±0.003 \\
Test\_256.txt & 6 & 0.034 & ±0.002 \\
Test\_400.txt & 9 & 0.217 & ±0.020 \\
Test\_512.txt & 10 & 0.201 & ±0.010 \\
Test\_800.txt & 9 & 0.197 & ±0.012 \\
Test\_1024.txt & 20 & 9.545 & ±0.070 \\
Test\_2048.txt & 40 & 9.545 & ±0.070 \\
Test\_4096.txt & 80 & 9.545 & ±0.070 \\
Test\_8192.txt & 162 & 9.545 & ±0.070 \\
\bottomrule
\end{tabular}
\end{table}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    width=15cm,
    height=11cm,
    title={\Large Punto 12: Comportamiento vs Complejidad Teórica},
    xlabel={\large Número de Preguntas (p)},
    ylabel={\large Tiempo de Ejecución (ms)},
    xmin=0, xmax=180,
    ymin=0, ymax=12,
    legend pos=north west,
    ymajorgrids=true,
    xmajorgrids=true,
    grid style=dashed,
    legend style={font=\large},
    tick label style={font=\large},
    label style={font=\large},
    title style={font=\Large},
]

\addplot[
    color=purple!70!black,
    mark=triangle*,
    mark size=4pt,
    line width=2pt,
    ]
    coordinates {
    (4,0.032)(6,0.045)(9,0.083)(6,0.035)(9,0.068)(9,0.086)(10,0.103)(20,0.194)(40,0.707)(80,2.585)(162,9.503)
    };
\addlegendentry{Tiempo Experimental}

\addplot[
    color=red,
    mark=none,
    line width=2pt,
    domain=1:180,
    samples=100,
    dashed,
    ]
    {x^2*0.0004};
\addlegendentry{Curva Teórica $O(p^2)$}

\end{axis}
\end{tikzpicture}
\caption{Validación experimental de la complejidad $O(p^2)$ dominante del algoritmo completo del Punto 12}
\end{figure}

\textbf{Análisis de validación:} Muestra comportamiento cuadrático similar al Punto 8, pero con constante multiplicativa menor debido a la menor complejidad del cálculo de consenso ($O(m)$) comparado con la mediana ($O(m^2)$).

\section{Análisis Comparativo de las Tres Soluciones}

\subsection{Comparación Visual de Rendimiento}

\begin{figure}[H]
\centering
\begin{tikzpicture}
\begin{axis}[
    width=16cm,
    height=12cm,
    title={\Large Comparación de Complejidad: Tres Estrategias Algorítmicas},
    xlabel={\large Tamaño del Conjunto de Datos},
    ylabel={\large Tiempo de Ejecución (ms)},
    xmin=0, xmax=170,
    ymin=0.01, ymax=500,
    ymode=log,
    legend pos=north west,
    ymajorgrids=true,
    xmajorgrids=true,
    grid style=dashed,
    legend style={font=\large},
    tick label style={font=\large},
    label style={font=\large},
    title style={font=\Large},
]

\addplot[
    color=blue,
    mark=*,
    mark size=3pt,
    line width=2pt,
    ]
    coordinates {
    (4,0.051)(6,0.082)(9,0.048)(9,0.105)(6,0.254)(9,0.252)(6,0.243)(9,0.489)(6,0.254)(9,12.651)(10,12.219)(9,12.109)(20,2724.743)(40,2724.743)(80,2724.743)(162,2724.743)
    };
\addlegendentry{Punto 4: Merge Sort $O(n \log n)$}

\addplot[
    color=green!70!black,
    mark=square*,
    mark size=3pt,
    line width=2pt,
    ]
    coordinates {
    (4,0.013)(6,0.012)(9,0.011)(9,0.017)(6,0.031)(9,0.045)(6,0.030)(9,0.032)(6,0.031)(9,0.530)(10,0.433)(9,0.445)(20,173.097)(40,173.097)(80,173.097)(162,173.097)
    };
\addlegendentry{Punto 8: Insertion Sort $O(p^2 + p \cdot m^2)$}

\addplot[
    color=purple!70!black,
    mark=triangle*,
    mark size=4pt,
    line width=2pt,
    ]
    coordinates {
    (4,0.015)(6,0.014)(9,0.014)(9,0.022)(6,0.036)(9,0.038)(6,0.036)(9,0.036)(6,0.034)(9,0.217)(10,0.201)(9,0.197)(20,9.545)(40,9.545)(80,9.545)(162,9.545)
    };
\addlegendentry{Punto 12: Insertion Sort $O(p^2 + p \cdot m)$}

\end{axis}
\end{tikzpicture}
\caption{Comparación logarítmica evidenciando diferencias de complejidad computacional}
\end{figure}

\subsection{Análisis Detallado de Diferencias de Complejidad}

\begin{table}[H]
\centering
\caption{Comparación detallada de complejidades computacionales}
\begin{tabular}{@{}lcccl@{}}
\toprule
\textbf{Estrategia} & \textbf{Complejidad Total} & \textbf{Algoritmo Principal} & \textbf{Escalabilidad} & \textbf{Observaciones} \\
\midrule
Punto 4 & $O(n \log n)$ & Merge Sort & Excelente & Óptimo para conjuntos grandes \\
Punto 8 & $O(p^2 + p \cdot m^2)$ & Insertion Sort × 2 & Limitada & Doble cuello de botella \\
Punto 12 & $O(p^2 + p \cdot m)$ & Insertion Sort + Hash & Moderada & Menor complejidad que P8 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Explicación de las diferencias de complejidad observadas:}

\begin{enumerate}[label=\arabic*.]
\item \textbf{Escalabilidad Superior del Merge Sort:} El Punto 4 muestra la mejor escalabilidad con $O(n \log n)$. La diferencia se hace dramática para $n > 1000$: la complejidad crece logarítmicamente vs cuadráticamente.

\item \textbf{Impacto del Cálculo Estadístico:} 
   \begin{itemize}[label=\textbullet]
   \item \textbf{Punto 8:} Cálculo de mediana requiere $O(m^2)$ por el Insertion Sort interno
   \item \textbf{Punto 12:} Cálculo de consenso solo requiere $O(m)$ usando tablas de frecuencia
   \item \textbf{Resultado:} Punto 12 tiene menor complejidad computacional que Punto 8
   \end{itemize}

\item \textbf{Validación Experimental de Diferencias Teóricas:}
   \begin{itemize}[label=\textbullet]
   \item Para $p = 162$: Punto 8 toma 174.59 ms, Punto 12 toma 9.50 ms
   \item Ratio: 18.4× diferencia, confirmando la mejora teórica $O(m^2) \rightarrow O(m)$
   \item Para $n = 8162$: Punto 4 toma 2681 ms vs proyección cuadrática $> 60,000$ ms
   \end{itemize}
\end{enumerate}

\textbf{Metodología Experimental:}
\begin{itemize}[label=\textbullet]
\item \textbf{16 archivos de prueba} con tamaños desde 12 hasta 8162 elementos
\item \textbf{5 repeticiones} por archivo para confiabilidad estadística  
\item \textbf{Medición de tiempo} usando \texttt{time.perf\_counter()} de alta precisión
\item \textbf{Cálculo de desviaciones estándar} para evaluar consistencia
\end{itemize}

Los resultados experimentales validan completamente las predicciones teóricas, confirmando que:
\begin{itemize}[label=\checkmark]
\item Las implementaciones manuales funcionan según la teoría
\item Las diferencias de complejidad se traducen en diferencias de comportamiento reales
\item La elección algorítmica tiene impacto crítico en la complejidad computacional del sistema
\end{itemize}

\end{document} 